var documenterSearchIndex = {"docs":
[{"location":"#TestPicker","page":"Home","title":"TestPicker","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TestPicker.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#TestPicker.INTERFACES","page":"Home","title":"TestPicker.INTERFACES","text":"INTERFACES\n\nGlobal collection of test block interfaces used by TestPicker.\n\nContains all registered TestBlockInterface implementations that TestPicker uses to recognize and parse different types of test blocks. By default includes StdTestset for standard @testset blocks.\n\nType\n\nVector{TestBlockInterface}: Collection of interface implementations\n\nDefault Contents\n\nStdTestset: Handles standard Julia @testset blocks\n\nModification\n\nUse add_interface! to register additional test block interfaces:\n\n# Add support for custom test blocks\nadd_interface!(MyCustomTestInterface())\n\nSee also\n\nTestBlockInterface, StdTestset, add_interface!\n\n\n\n\n\n","category":"constant"},{"location":"#TestPicker.LATEST_EVAL","page":"Home","title":"TestPicker.LATEST_EVAL","text":"LATEST_EVAL\n\nGlobal reference to the most recently executed test evaluations.\n\nStores a vector of EvalTest objects representing the last set of tests that were executed. This allows for re-running the same tests without going through the selection interface again.\n\nType\n\nRef{Union{Nothing,Vector{EvalTest}}}: Initially nothing, becomes a vector after first test execution\n\nUsage\n\nSet automatically when tests are executed\nCan be re-run using the - command in test mode\nCleared when new test files are executed (not individual test blocks)\n\nExamples\n\n# In test mode REPL:\n# Run some tests first, then:\ntest> -    # Re-runs the last executed tests\n\n\n\n\n\n","category":"constant"},{"location":"#TestPicker.TESTENV_CACHE","page":"Home","title":"TestPicker.TESTENV_CACHE","text":"TESTENV_CACHE\n\nCache for TestEnv temporary environments to avoid triggering recompilation on every test run.\n\nThis constant stores a mapping from PackageSpec objects to their corresponding temporary test environment paths. Reusing these environments improves performance by avoiding the overhead of recreating test environments.\n\n\n\n\n\n","category":"constant"},{"location":"#TestPicker.TESTMODE_TRIGGER","page":"Home","title":"TestPicker.TESTMODE_TRIGGER","text":"Trigger key to get into test mode.\n\n\n\n\n\n","category":"constant"},{"location":"#TestPicker.EvalTest","page":"Home","title":"TestPicker.EvalTest","text":"EvalTest\n\nContainer for executable test code and its associated metadata.\n\nCombines a Julia expression representing test code with metadata about its source and context. Used throughout TestPicker for tracking and executing tests.\n\nFields\n\nex::Expr: The executable test expression (may include preamble and wrapper code)\ninfo::TestInfo: Metadata about the test's source and identification\n\nUsage\n\nEvalTest objects are created during test parsing and stored in LATEST_EVAL for re-execution and result tracking.\n\nSee also\n\nTestInfo, eval_in_module, LATEST_EVAL\n\n\n\n\n\n","category":"type"},{"location":"#TestPicker.QueryType","page":"Home","title":"TestPicker.QueryType","text":"QueryType\n\nEnumeration of different types of test queries supported by the test REPL mode.\n\nValues\n\nTestFileQuery: Query for running tests from specific files\nTestsetQuery: Query for running specific test sets (format: \"file:testset\")\nLatestEval: Re-run the most recently evaluated tests (triggered by \"-\")\nInspectResults: View test results visualization (triggered by \"?\")\nUnmatchedQuery: Query that couldn't be parsed or is invalid\n\n\n\n\n\n","category":"type"},{"location":"#TestPicker.StdTestset","page":"Home","title":"TestPicker.StdTestset","text":"StdTestset <: TestBlockInterface\n\nStandard implementation of TestBlockInterface for @testset blocks from Julia's Test.jl standard library.\n\nThis is the built-in interface for recognizing and processing standard Julia test sets. It handles @testset blocks commonly used in Julia testing and provides the necessary preamble to load the Test.jl package.\n\nBehavior\n\nRecognizes syntax nodes that start with @testset\nExtracts test set names as labels for display\nAutomatically includes using Test as preamble\nNo expression transformation (uses default identity)\n\nExamples\n\n# This testset would be recognized:\n@testset \"Basic arithmetic tests\" begin\n    @test 1 + 1 == 2\n    @test 2 * 3 == 6\nend\n\n# The label would be: \"Basic arithmetic tests\"\n\nSee also\n\nTestBlockInterface, istestblock, blocklabel, preamble\n\n\n\n\n\n","category":"type"},{"location":"#TestPicker.SyntaxBlock","page":"Home","title":"TestPicker.SyntaxBlock","text":"SyntaxBlock\n\nA container for a test block and its associated preamble statements.\n\nContains all the necessary components to execute a test block, including any setup  code that needs to run beforehand. Can be easily converted into an evaluatable expression.\n\nFields\n\npreamble::Vector{SyntaxNode}: Collection of preamble statements (imports, assignments, etc.)\ntestblock::SyntaxNode: The actual test block node (e.g., @testset)\ninterface::TestBlockInterface: The interface implementation used to parse this block\n\n\n\n\n\n","category":"type"},{"location":"#TestPicker.TestBlockInfo","page":"Home","title":"TestPicker.TestBlockInfo","text":"TestBlockInfo\n\nMetadata container for a test block, including its location and identification information.\n\nStores essential information about a test block's location within a file and provides a label for identification and display purposes.\n\nFields\n\nlabel::String: Human-readable label for the test block (e.g., test set name)\nfile_name::String: Name of the file containing the test block\nline_start::Int: Starting line number of the test block (1-indexed)\nline_end::Int: Ending line number of the test block (1-indexed)\n\n\n\n\n\n","category":"type"},{"location":"#TestPicker.TestBlockInterface","page":"Home","title":"TestPicker.TestBlockInterface","text":"TestBlockInterface\n\nAbstract interface for defining and recognizing different types of test blocks in Julia code.\n\nThe TestBlockInterface allows you to define different types of test blocks that you would like TestPicker to find and evaluate. The interface is relatively simple and flexible.\n\nImplementation Requirements\n\nTo create a custom test block interface, define a subtype and implement the required methods:\n\nstruct MyTestBlock <: TestBlockInterface end\n\nRequired Methods\n\nistestblock(::MyTestBlock, node::SyntaxNode)::Bool: Determines whether a given SyntaxNode represents a test block\nblocklabel(::MyTestBlock, node::SyntaxNode)::String: Produces a (preferably) unique label for filtering and display\n\nOptional Methods\n\npreamble(::MyTestBlock)::Union{Nothing, Expr}: Returns additional preamble that the test block might require (default: nothing)\nexpr_transform(::MyTestBlock, ex::Expr)::Expr: Transforms the test block expression before evaluation (default: identity)\n\nExamples\n\n# Define a custom interface for @test_nowarn blocks\nstruct NoWarnTestInterface <: TestBlockInterface end\n\nfunction istestblock(::NoWarnTestInterface, node::SyntaxNode)\n    nodes = JuliaSyntax.children(node)\n    return !isnothing(nodes) && !isempty(nodes) && \n           Expr(first(nodes)) == Symbol(\"@test_nowarn\")\nend\n\nfunction blocklabel(::NoWarnTestInterface, node::SyntaxNode)\n    return \"nowarn: \" * JuliaSyntax.sourcetext(JuliaSyntax.children(node)[2])\nend\n\nSee also\n\nStdTestset, istestblock, blocklabel\n\n\n\n\n\n","category":"type"},{"location":"#TestPicker.TestInfo","page":"Home","title":"TestPicker.TestInfo","text":"TestInfo\n\nContainer for test execution metadata and location information.\n\nStores essential information about a test's source location and context, used for tracking test execution and displaying results.\n\nFields\n\nfilename::String: Source file containing the test\nlabel::String: Human-readable test identifier (e.g., testset name)\nline::Int: Line number where the test begins\n\nSee also\n\nEvalTest, save_test_results\n\n\n\n\n\n","category":"type"},{"location":"#TestPicker.add_interface!-Tuple{TestBlockInterface}","page":"Home","title":"TestPicker.add_interface!","text":"add_interface!(interface::TestBlockInterface) -> Vector{TestBlockInterface}\n\nRegister a new test block interface with TestPicker.\n\nAdds the provided interface to the global INTERFACES collection, enabling TestPicker to recognize and process the corresponding test block types. Duplicates are automatically removed to prevent redundant processing.\n\nArguments\n\ninterface::TestBlockInterface: The interface implementation to register\n\nReturns\n\nVector{TestBlockInterface}: The updated interfaces collection\n\nExamples\n\n# Define a custom interface\nstruct MyTestInterface <: TestBlockInterface end\n# ... implement required methods ...\n\n# Register with TestPicker\nadd_interface!(MyTestInterface())\n\n# Now TestPicker will recognize your test blocks\n\nSide Effects\n\nModifies the global INTERFACES collection, affecting all subsequent test parsing and execution operations.\n\nSee also\n\nINTERFACES, TestBlockInterface\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.blocklabel-Union{Tuple{T}, Tuple{T, JuliaSyntax.SyntaxNode}} where T<:TestBlockInterface","page":"Home","title":"TestPicker.blocklabel","text":"blocklabel(interface::T, node::SyntaxNode)::String where {T<:TestBlockInterface}\n\nGenerate a descriptive label for a test block to be used in filtering and display.\n\nThis is a required method that must be implemented by all concrete subtypes of TestBlockInterface. It should produce a (preferably) unique label that helps users identify and select specific test blocks.\n\nArguments\n\ninterface::T: The test block interface implementation  \nnode::SyntaxNode: The syntax node representing the test block\n\nReturns\n\nString: A descriptive label for the test block\n\nImplementation Notes\n\nLabels should be human-readable and distinctive\nConsider including test names, descriptions, or other identifying information\n\nExamples\n\n# For @testset blocks, extract the test set name:\nfunction blocklabel(::StdTestset, node::SyntaxNode)\n    return JuliaSyntax.sourcetext(JuliaSyntax.children(node)[2])\nend\n\nSee also\n\nTestBlockInterface, istestblock\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.build_info_to_syntax-Tuple{Vector{<:TestBlockInterface}, AbstractString, AbstractVector{<:AbstractString}}","page":"Home","title":"TestPicker.build_info_to_syntax","text":"build_info_to_syntax(interfaces, root, matched_files) -> (Dict{TestBlockInfo,SyntaxBlock}, Dict{String,TestBlockInfo})\n\nParse matched files and build mapping structures for test block selection and display.\n\nExtracts all test blocks from the provided files and creates two mappings:\n\nFrom test block metadata to syntax information \nFrom human-readable display strings (for fzf) to test block metadata\n\nArguments\n\ninterfaces::Vector{<:TestBlockInterface}: Test block interfaces for parsing\nroot::AbstractString: Root directory path for resolving relative file paths\nmatched_files::AbstractVector{<:AbstractString}: List of files to parse\n\nReturns\n\nTuple{Dict{TestBlockInfo,SyntaxBlock}, Dict{String,TestBlockInfo}}: \nFirst element: Maps test block info to syntax blocks\nSecond element: Maps formatted display strings to test block info\n\nNotes\n\nThe display strings are formatted with padding for alignment in fzf, showing: \"<label> | <filename>:<line_start>-<line_end>\"\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.clean_results_file-Tuple{Pkg.Types.PackageSpec}","page":"Home","title":"TestPicker.clean_results_file","text":"This empty the file before appending new results.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.clean_source-Tuple{LineNumberNode}","page":"Home","title":"TestPicker.clean_source","text":"Obtain the source from the LineNumberNode.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.clear_testenv_cache-Tuple{}","page":"Home","title":"TestPicker.clear_testenv_cache","text":"clear_testenv_cache()\n\nClear the TestEnv cache to force recreation of test environments on next use.\n\nEmpties the TESTENV_CACHE dictionary, which will cause subsequent test evaluations to create fresh test environments. This can be useful when test dependencies have changed or when troubleshooting environment-related issues.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.create_repl_test_mode-Tuple{REPL.AbstractREPL, REPL.LineEdit.Prompt}","page":"Home","title":"TestPicker.create_repl_test_mode","text":"create_repl_test_mode(repl::AbstractREPL, main::LineEdit.Prompt) -> LineEdit.Prompt\n\nCreate a new REPL mode specifically for test operations.\n\nConstructs a custom REPL prompt mode that handles test-specific commands and provides an isolated interface for TestPicker operations. The mode includes proper history support, key bindings, and command processing.\n\nArguments\n\nrepl::AbstractREPL: The REPL instance to create the mode for\nmain::LineEdit.Prompt: The main REPL mode to inherit settings from\n\nReturns\n\nLineEdit.Prompt: The configured test mode prompt ready for use\n\nFeatures\n\nCustom prompt with magenta coloring (if supported)\nSticky mode behavior for continued test operations\nIntegrated history and search functionality\nError handling for test execution failures\nAutomatic return to main mode when appropriate\n\nSee also\n\ninit_test_repl_mode, test_mode_do_cmd\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.current_pkg-Tuple{}","page":"Home","title":"TestPicker.current_pkg","text":"current_pkg() -> PackageSpec\n\nGet the current package specification from the active Pkg environment.\n\nThis is a more flexible version of current_pkg_name from TestEnv that returns the full PackageSpec object rather than just the package name. This provides access to additional package metadata needed by TestPicker.\n\nReturns\n\nPackageSpec: The package specification for the current project\n\nThrows\n\nTestEnvError: If trying to activate test environment of an unnamed project\n\nNotes\n\nThe function examines the current Pkg context to determine the active package. This is essential for TestPicker to understand which package's tests are being executed and where to store results.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.eval_in_module-Tuple{TestPicker.EvalTest, Pkg.Types.PackageSpec}","page":"Home","title":"TestPicker.eval_in_module","text":"eval_in_module(eval_test::EvalTest, pkg::PackageSpec) -> Nothing\n\nExecute a test block in an isolated module with the appropriate test environment activated.\n\nThis function provides the core test execution functionality for TestPicker. It creates a temporary module, activates the package's test environment, and evaluates the test code in isolation to prevent interference between different test runs.\n\nArguments\n\neval_test::EvalTest: Contains the test expression and metadata\npkg::PackageSpec: Package specification for environment setup\n\nProcess Overview\n\nEnvironment Setup: Activates test environment (cached or new)\nModule Creation: Creates isolated module for test execution  \nCode Preparation: Prepends necessary imports and setup code\nExecution: Evaluates test in correct directory context with Revise support\nCleanup: Restores original environment and cleans temporary module\n\nSide Effects\n\nTemporarily changes active Pkg environment\nCreates and cleans up temporary module in Main\nMay trigger Revise.revise() for code reloading\nChanges working directory during execution\nOutputs execution information via @info\n\nEnvironment Management\n\nUses TESTENV_CACHE for performance optimization\nTemporarily disables auto-precompilation during setup\nRestores original environment and precompilation settings after execution\n\nError Handling\n\nEnsures environment restoration even if test execution fails\nCleans up temporary module variables in finally block\nPreserves original working directory\n\nExamples\n\n# Execute a test block from an EvalTest object\ntest = EvalTest(:(using Test; @test 1+1 == 2), TestInfo(\"test.jl\", \"arithmetic\", 1))\npkg = PackageSpec(name=\"MyPackage\", path=\"/path/to/package\")\neval_in_module(test, pkg)\n\nSee also\n\nEvalTest, TESTENV_CACHE, prepend_ex, clear_testenv_cache\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.expr_transform-Tuple{TestBlockInterface, Expr}","page":"Home","title":"TestPicker.expr_transform","text":"expr_transform(interface::TestBlockInterface, ex::Expr)::Expr\n\nTransform a test block expression before evaluation.\n\nThis optional method allows test block interfaces to modify the test block expression before it is executed. This can be useful for adding wrapper code, modifying test behavior, or adapting different test formats.\n\nArguments\n\ninterface::TestBlockInterface: The test block interface implementation\nex::Expr: The test block expression to transform\n\nReturns\n\nExpr: The transformed expression ready for evaluation\n\nDefault Behavior\n\nThe default implementation returns the expression unchanged (identity transformation).\n\nExamples\n\n# Add timing information to test blocks:\nfunction expr_transform(::TimedTestInterface, ex::Expr)\n    return quote\n        start_time = time()\n        result = $ex\n        elapsed = time() - start_time\n        println(\"Test completed in $(elapsed)s\")\n        result\n    end\nend\n\n# Wrap tests in additional error handling:\nfunction expr_transform(::SafeTestInterface, ex::Expr)\n    return quote\n        try\n            $ex\n        catch e\n            @warn \"Test failed with error: $e\"\n            rethrow()\n        end\n    end\nend\n\nSee also\n\nTestBlockInterface, preamble\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.fzf_testblock-Tuple{Vector{<:TestBlockInterface}, AbstractString, AbstractString}","page":"Home","title":"TestPicker.fzf_testblock","text":"fzf_testblock(interfaces, fuzzy_file, fuzzy_testset) -> Nothing\n\nInteractive test block selection and execution workflow using fzf.\n\nProvides a two-stage fuzzy finding process:\n\nFilter test files based on fuzzy_file query\nSelect specific test blocks from filtered files based on fuzzy_testset query\n\nSelected test blocks are executed immediately with results saved to the package's results file. The latest evaluation is stored in LATEST_EVAL[] for reference.\n\nArguments\n\ninterfaces::Vector{<:TestBlockInterface}: Test block interfaces for parsing\nfuzzy_file::AbstractString: Query pattern for filtering test files\nfuzzy_testset::AbstractString: Query pattern for filtering test block names\n\nSide Effects\n\nExecutes selected test blocks\nUpdates LATEST_EVAL[] with executed tests\nCleans and writes to results file\nMay modify package test state\n\nExamples\n\n# Find and run tests matching \"math\" files and \"addition\" test names\nfzf_testblock([StdTestset()], \"math\", \"addition\")\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.fzf_testfile-Tuple{AbstractString}","page":"Home","title":"TestPicker.fzf_testfile","text":"fzf_testfile(query::AbstractString) -> Nothing\n\nInteractive test file selection and execution workflow.\n\nCombines file selection and execution in a single workflow: uses fzf to select test files based on the query, then runs all selected files in the test environment.\n\nArguments\n\nquery::AbstractString: Initial search pattern for filtering test files\n\nProcess\n\nGet current package context\nPresent fzf interface for file selection\nExecute all selected test files\nHandle results and error reporting\n\nSide Effects\n\nUpdates LATEST_EVAL[] with executed tests\nClears and populates results file with any failures/errors\nMay modify test environment state\n\nExamples\n\n# Run tests matching \"integration\"\nfzf_testfile(\"integration\")\n\n# Run all test files (empty query shows all)\nfzf_testfile(\"\")\n\nSee also\n\nselect_test_files, run_test_files\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.get_matching_files-Tuple{AbstractString, AbstractVector{<:AbstractString}}","page":"Home","title":"TestPicker.get_matching_files","text":"get_matching_files(file_query::AbstractString, test_files::AbstractVector{<:AbstractString}) -> Vector{String}\n\nFilter test files using fzf's non-interactive filtering based on the given query.\n\nUses fzf --filter to perform fuzzy matching on the provided list of test files, returning only those that match the query pattern.\n\nArguments\n\nfile_query::AbstractString: Fuzzy search pattern to match against file names\ntest_files::AbstractVector{<:AbstractString}: List of test file paths to filter\n\nReturns\n\nVector{String}: List of file paths that match the query\n\nExamples\n\nfiles = [\"test/test_math.jl\", \"test/test_string.jl\", \"test/integration.jl\"]\nget_matching_files(\"math\", files)  # Returns [\"test/test_math.jl\"]\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.get_preview_dimension","page":"Home","title":"TestPicker.get_preview_dimension","text":"Utility function to adapt the size of the text width and line position.\n\n\n\n\n\n","category":"function"},{"location":"#TestPicker.get_test_files","page":"Home","title":"TestPicker.get_test_files","text":"get_test_files(pkg::PackageSpec=current_pkg()) -> (String, Vector{String})\n\nDiscover and return all Julia test files for a package.\n\nRecursively searches the package's test directory to find all .jl files, returning both the test directory path and the collection of relative file paths.\n\nArguments\n\npkg::PackageSpec: Package specification (defaults to current package)\n\nReturns\n\nTuple{String, Vector{String}}: \nFirst element: Absolute path to the test directory\nSecond element: Vector of test file paths relative to test directory\n\nNotes\n\nOnly includes files with .jl extension\nSearches recursively through subdirectories\nFile paths are normalized and relative to test directory root\n\nExamples\n\ntest_dir, files = get_test_files()\n# test_dir: \"/path/to/MyPackage/test\"\n# files: [\"runtests.jl\", \"subdir/test_math.jl\", \"test_utils.jl\"]\n\n\n\n\n\n","category":"function"},{"location":"#TestPicker.get_testblocks-Tuple{Vector{<:TestBlockInterface}, AbstractString}","page":"Home","title":"TestPicker.get_testblocks","text":"get_testblocks(interfaces::Vector{<:TestBlockInterface}, file::AbstractString) -> Vector{SyntaxBlock}\n\nParse a Julia file and extract all test blocks with their associated preamble statements.\n\nFor each test block found (including nested ones), collects all preceding preamble  statements that should be executed before the test block. Uses the provided interfaces to determine what constitutes a test block.\n\nArguments\n\ninterfaces::Vector{<:TestBlockInterface}: Collection of test block interfaces to use for parsing\nfile::AbstractString: Path to the Julia file to parse\n\nReturns\n\nVector{SyntaxBlock}: Collection of parsed test blocks with their preambles\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.identify_query-Tuple{AbstractString}","page":"Home","title":"TestPicker.identify_query","text":"identify_query(input::AbstractString) -> (QueryType, Tuple)\n\nParse user input in test mode and identify the type of operation requested.\n\nAnalyzes the input string to determine what kind of test operation the user wants to perform and extracts the relevant parameters for that operation.\n\nArguments\n\ninput::AbstractString: The raw input from the test mode REPL\n\nReturns\n\nTuple{QueryType, Tuple}: The query type and associated parameters\n\nQuery Formats\n\n\"-\": Re-run latest evaluation (returns LatestEval with stored tests)\n\"?\": Inspect test results (returns InspectResults with empty tuple)  \n\"file:testset\": Run specific test set (returns TestsetQuery with file and testset)\n\"filename\": Run tests from file (returns TestFileQuery with filename and empty testset)\n\nExamples\n\nidentify_query(\"test_math.jl\")           # (TestFileQuery, (\"test_math.jl\", \"\"))\nidentify_query(\"test_math.jl:addition\")  # (TestsetQuery, (\"test_math.jl\", \"addition\"))\nidentify_query(\"-\")                      # (LatestEval, <previous_tests>)\nidentify_query(\"?\")                      # (InspectResults, ())\n\nError Handling\n\nReturns UnmatchedQuery for inputs that cannot be parsed\nHandles case where no previous evaluation exists for \"-\" command\n\nSee also\n\nQueryType, test_mode_do_cmd\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.init_test_repl_mode-Tuple{REPL.AbstractREPL}","page":"Home","title":"TestPicker.init_test_repl_mode","text":"init_test_repl_mode(repl::AbstractREPL) -> Nothing\n\nInitialize and add test mode to the REPL interface.\n\nSets up a custom REPL mode for TestPicker that can be accessed by typing '!' at the beginning of a line. The test mode provides specialized commands for running and inspecting tests interactively.\n\nArguments\n\nrepl::AbstractREPL: The REPL instance to modify\n\nSide Effects\n\nAdds a new test mode to the REPL interface\nModifies the main mode's keymap to include the trigger\nSets up mode switching behavior and key bindings\n\nNotes\n\nThe test mode supports:\n\nStandard REPL features (history, search, etc.)\nCustom test commands and query parsing\nSeamless switching between main and test modes\n\nSee also\n\ncreate_repl_test_mode\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.ispreamble-Tuple{JuliaSyntax.SyntaxNode}","page":"Home","title":"TestPicker.ispreamble","text":"ispreamble(node::SyntaxNode) -> Bool\n\nCheck if a statement qualifies as a preamble that should be executed before test blocks.\n\nA preamble statement is any statement that sets up the testing environment, such as:\n\nFunction calls (:call)\nImport/using statements (:using, :import)  \nVariable assignments (:=)\nMacro calls (:macrocall)\nFunction definitions (:function)\n\nArguments\n\nnode::SyntaxNode: The syntax node to check\n\nReturns\n\nBool: true if the node represents a preamble statement, false otherwise\n\nExamples\n\n# These would return true:\nusing Test\nimport MyModule\nx = 10\n@testset \"setup\" begin end\nfunction helper() end\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.istestblock-Union{Tuple{T}, Tuple{T, JuliaSyntax.SyntaxNode}} where T<:TestBlockInterface","page":"Home","title":"TestPicker.istestblock","text":"istestblock(interface::T, node::SyntaxNode)::Bool where {T<:TestBlockInterface}\n\nDetermine whether a syntax node represents a test block according to the given interface.\n\nThis is a required method that must be implemented by all concrete subtypes of TestBlockInterface. It examines a syntax node and decides whether it represents a test block that should be recognized by TestPicker.\n\nArguments\n\ninterface::T: The test block interface implementation\nnode::SyntaxNode: The syntax node to examine\n\nReturns\n\nBool: true if the node represents a test block, false otherwise\n\nExamples\n\n# For @testset blocks:\nfunction istestblock(::StdTestset, node::SyntaxNode)\n    nodes = JuliaSyntax.children(node)\n    return !isnothing(nodes) && !isempty(nodes) && \n           Expr(first(nodes)) == Symbol(\"@testset\")\nend\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.pick_testblock-Tuple{Dict{String, TestPicker.TestBlockInfo}, AbstractString, AbstractString}","page":"Home","title":"TestPicker.pick_testblock","text":"pick_testblock(tabled_keys, testset_query, root) -> Vector{String}\n\nPresent an interactive fzf interface for selecting test blocks to execute.\n\nLaunches fzf with a preview window (using bat) that allows users to select one or more test blocks from the filtered list. The preview shows the actual test code with syntax highlighting.\n\nArguments\n\ntabled_keys::Dict{String,TestBlockInfo}: Mapping from display strings to test block info\ntestset_query::AbstractString: Initial query to filter test block names\nroot::AbstractString: Root directory for file path resolution\n\nReturns\n\nVector{String}: List of selected display strings corresponding to chosen test blocks\n\nFeatures\n\nMulti-selection enabled (-m flag)\nPreview window shows test code with syntax highlighting\nInitial query pre-filters results\nSearch limited to visible test labels (not file paths)\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.preamble-Tuple{TestBlockInterface}","page":"Home","title":"TestPicker.preamble","text":"preamble(interface::TestBlockInterface)::Union{Nothing, Expr}\n\nReturn additional preamble code specific to the test block interface.\n\nThis optional method allows test block interfaces to specify setup code that should be executed before any test blocks of this type. Common uses include importing required packages or setting up test environment variables.\n\nArguments\n\ninterface::TestBlockInterface: The test block interface implementation\n\nReturns\n\nUnion{Nothing, Expr}: Preamble expression to execute, or nothing if no preamble needed\n\nDefault Behavior\n\nThe default implementation returns nothing, indicating no additional preamble is required.\n\nExamples\n\n# StdTestset requires Test.jl to be loaded:\nfunction preamble(::StdTestset)\n    return :(using Test)\nend\n\n# Custom interface might need multiple setup steps:\nfunction preamble(::MyCustomInterface)\n    return quote\n        using Test, Random\n        Random.seed!(1234)\n    end\nend\n\nSee also\n\nTestBlockInterface, prepend_preamble_statements\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.prepend_ex-Tuple{Any, Expr}","page":"Home","title":"TestPicker.prepend_ex","text":"prepend_ex(ex, new_line::Expr) -> Expr\n\nPrepend a new expression to an existing expression, handling block structure appropriately.\n\nIf the target expression is already a block, the new expression is prepended to the beginning of the block. Otherwise, a new block is created containing both expressions.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.prepend_preamble_statements-Tuple{TestBlockInterface, Vector{Expr}}","page":"Home","title":"TestPicker.prepend_preamble_statements","text":"prepend_preamble_statements(interface::TestBlockInterface, preambles::Vector{Expr}) -> Vector{Expr}\n\nCombine interface-specific preamble with existing preamble statements.\n\nTakes the preamble from the interface (if any) and prepends it to the existing collection of preamble statements, ensuring interface requirements are satisfied before test execution.\n\nArguments\n\ninterface::TestBlockInterface: The test block interface implementation\npreambles::Vector{Expr}: Existing preamble statements from the test file\n\nReturns\n\nVector{Expr}: Combined preamble statements with interface preamble first\n\nExamples\n\ninterface = StdTestset()\nexisting = [:(x = 1), :(y = 2)]\nresult = prepend_preamble_statements(interface, existing)\n# Returns: [:(using Test), :(x = 1), :(y = 2)]\n\nSee also\n\npreamble, TestBlockInterface\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.preview_content-Tuple{Test.Error}","page":"Home","title":"TestPicker.preview_content","text":"We connect the error with the backtrace to be previewed.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.remove_ansi-Tuple{AbstractString}","page":"Home","title":"TestPicker.remove_ansi","text":"File names come with ansi characters and break stuff...\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.run_test_file-Tuple{AbstractString, Pkg.Types.PackageSpec}","page":"Home","title":"TestPicker.run_test_file","text":"run_test_file(file::AbstractString, pkg::PackageSpec) -> Any\n\nExecute a single test file in an isolated testset within the package test environment.\n\nWraps the test file in a testset named after the package and file, handles test failures gracefully, and updates the global test state for later inspection.\n\nArguments\n\nfile::AbstractString: Path to the test file to execute\npkg::PackageSpec: Package specification for environment and naming\n\nProcess\n\nCreates a testset named \"{package} - {file}\"\nIncludes the test file within the testset\nCatches and saves any test failures/errors\nUpdates LATEST_EVAL[] with the test execution\nEvaluates in isolated module environment\n\nTest Structure\n\nThe file is executed within this structure:\n\n@testset \"PackageName - filepath\" begin\n    include(\"filepath\")\nend\n\nSide Effects\n\nUpdates or initializes LATEST_EVAL[] global state\nMay save test results to results file on failures\nExecutes file in test environment context\n\nError Handling\n\nTest failures are caught and saved rather than propagated\nNon-test errors are re-thrown\nFile-level errors are properly contextualized\n\nSee also\n\neval_in_module, save_test_results, EvalTest\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.run_test_files-Tuple{AbstractVector{<:AbstractString}, Pkg.Types.PackageSpec}","page":"Home","title":"TestPicker.run_test_files","text":"run_test_files(files::AbstractVector{<:AbstractString}, pkg::PackageSpec) -> Nothing\n\nExecute a collection of test files in the package test environment.\n\nRuns each provided test file in sequence, handling errors gracefully and updating the test evaluation state. Each file is wrapped in a testset and executed in isolation.\n\nArguments\n\nfiles::AbstractVector{<:AbstractString}: Full paths to test files to execute\npkg::PackageSpec: Package specification for test environment context\n\nBehavior\n\nReturns early if no files provided (preserves existing LATEST_EVAL state)\nResets LATEST_EVAL[] to empty array for new test run\nClears results file before execution\nValidates file existence before attempting execution\nContinues execution even if individual files fail\n\nSide Effects\n\nModifies LATEST_EVAL[] global state\nClears and populates results file\nMay output error messages for missing files\n\nError Handling\n\nValidates file paths before execution\nReports missing files as errors with bug report guidance\nIndividual file failures don't stop batch execution\n\nSee also\n\nrun_test_file, select_test_files, clean_results_file\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.save_test_results-Tuple{Test.TestSetException, TestPicker.TestInfo, Pkg.Types.PackageSpec}","page":"Home","title":"TestPicker.save_test_results","text":"save_test_results(testset::Test.TestSetException, testinfo::TestInfo, pkg::PackageSpec) -> Nothing\n\nSave test failures and errors from a test set to the package's results file.\n\nProcesses a test set exception containing failed and errored tests, formats them for display in the results viewer, and appends them to the package's results file. Each test result includes the test description, source location, detailed error information, and context.\n\nArguments\n\ntestset::Test.TestSetException: Exception containing failed/errored tests\ntestinfo::TestInfo: Information about the test block that was executed\npkg::PackageSpec: Package specification for file organization\n\nFile Format\n\nEach test result is stored as a line with components separated by separator():\n\nTest description (from list_view)\nCleaned source location (from clean_source)\nDetailed error content (from preview_content)\nTest context (from context)\n\nSide Effects\n\nCreates results file if it doesn't exist\nAppends new results to existing file content\nResults are null-separated for fzf compatibility\n\nNotes\n\nResults are formatted specifically for consumption by visualize_test_results and the fzf-based results viewer interface.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.select_test_files","page":"Home","title":"TestPicker.select_test_files","text":"select_test_files(query::AbstractString, pkg::PackageSpec=current_pkg()) -> Vector{String}\n\nInteractively select test files using fzf based on a fuzzy search query.\n\nPresents an fzf interface showing all test files for the package, with syntax-highlighted preview using bat. Users can select multiple files and the query pre-filters the results.\n\nArguments\n\nquery::AbstractString: Initial fuzzy search pattern for filtering test files\npkg::PackageSpec: Package specification (defaults to current package)\n\nReturns\n\nVector{String}: Full paths to selected test files, empty if no selection made\n\nFeatures\n\nMulti-selection enabled (can choose multiple test files)\nSyntax-highlighted preview of file contents\nPre-filtered results based on initial query\nReturns full absolute paths ready for execution\n\nExamples\n\n# Select test files matching \"math\"\nfiles = select_test_files(\"math\")\n\n# Select from specific package\npkg = PackageSpec(name=\"MyPackage\")\nfiles = select_test_files(\"integration\", pkg)\n\nSee also\n\nget_test_files, fzf_testfile\n\n\n\n\n\n","category":"function"},{"location":"#TestPicker.separator-Tuple{}","page":"Home","title":"TestPicker.separator","text":"Separator used by fzf to distinguish the different data components.\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.test_mode_do_cmd-Tuple{REPL.AbstractREPL, String}","page":"Home","title":"TestPicker.test_mode_do_cmd","text":"test_mode_do_cmd(repl::AbstractREPL, input::String) -> Nothing\n\nExecute test commands received in the test REPL mode.\n\nProcesses user input from the test mode, identifies the requested operation, and dispatches to the appropriate test execution or inspection function.\n\nArguments\n\nrepl::AbstractREPL: The REPL instance for result visualization\ninput::String: The command string entered by the user\n\nCommands Supported\n\nFile queries: Run tests from matching files using fuzzy search\nTestset queries: Run specific test sets using file:testset syntax\nLatest evaluation: Re-run previously executed tests with \"-\"\nResult inspection: View test results with \"?\"\n\nSide Effects\n\nMay execute test code and modify package environments\nUpdates the latest evaluation cache\nCan display test results in the REPL\nOutputs informational messages and errors\n\nError Handling\n\nCatches and reports TestSetException errors from test execution\nProvides warning for non-interactive usage\nHandles unrecognized query formats\n\nExamples\n\n# In test mode:\n# \"math\"              # Run tests from files matching \"math\"\n# \"test_calc.jl:add\"  # Run \"add\" testset from test_calc.jl\n# \"-\"                 # Re-run last tests\n# \"?\"                 # View test results\n\nSee also\n\nidentify_query, fzf_testfile, fzf_testblock, visualize_test_results\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.testblock_list-Tuple{Vector{<:AbstractString}, Dict{TestPicker.TestBlockInfo, TestPicker.SyntaxBlock}, Dict{String, TestPicker.TestBlockInfo}, Pkg.Types.PackageSpec}","page":"Home","title":"TestPicker.testblock_list","text":"testblock_list(choices, info_to_syntax, display_to_info, pkg) -> Vector{EvalTest}\n\nConvert user-selected test block choices into executable test objects.\n\nTakes the selected display strings from fzf and converts them into EvalTest objects that can be evaluated. Each test is wrapped in a try-catch block to handle test failures gracefully and save results.\n\nArguments\n\nchoices::Vector{<:AbstractString}: Selected display strings from fzf\ninfo_to_syntax::Dict{TestBlockInfo,SyntaxBlock}: Mapping from test info to syntax blocks\ndisplay_to_info::Dict{String,TestBlockInfo}: Mapping from display strings to test info\npkg::PackageSpec: Package specification for test context\n\nReturns\n\nVector{EvalTest}: Collection of executable test objects ready for evaluation\n\n\n\n\n\n","category":"method"},{"location":"#TestPicker.visualize_test_results","page":"Home","title":"TestPicker.visualize_test_results","text":"visualize_test_results(repl::AbstractREPL=Base.active_repl, pkg::PackageSpec=current_pkg()) -> Nothing\n\nInteractive visualization of test failures and errors using fzf interface.\n\nCreates a loop-based interface for browsing test failures and errors from the most recent test execution. Provides syntax-highlighted previews of stack traces and allows editing of test files directly from the interface.\n\nArguments\n\nrepl::AbstractREPL: REPL instance for terminal operations (defaults to active REPL)\npkg::PackageSpec: Package specification for locating results (defaults to current package)\n\nFeatures\n\nTwo-level navigation: \nBrowse failed/errored tests with stack trace preview\nDrill down into stack traces with source code preview\nSyntax highlighting: Uses bat for colored display of Julia code\nEditor integration: Ctrl+e opens files in configured editor\nSource location: Shows relevant source code around error locations\n\nInterface Controls\n\nMain view:\nEnter: Drill down into stack trace for selected test\nCtrl+e: Edit the test file\nEsc: Exit the viewer\nStack trace view:\nCtrl+e: Edit source file at specific line\nEsc: Return to main test view\n\nPrerequisites\n\nTest results file must exist (created by running tests with failures/errors)\nExternal dependencies: fzf, bat, configured editor\n\nError Handling\n\nWarns if no results file exists\nGracefully handles missing stack traces for simple failures\nContinues operation if source files cannot be located\n\nExamples\n\n# View results for current package\nvisualize_test_results()\n\n# View results for specific package\npkg = PackageSpec(name=\"MyPackage\")\nvisualize_test_results(Base.active_repl, pkg)\n\nSee also\n\nsave_test_results, get_preview_dimension, separator\n\n\n\n\n\n","category":"function"}]
}
